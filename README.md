# CS-230
Repository for CS 230 Operating Platforms

The client for this project was The Gaming Room, a company that wanted to expand their existing Android game, Draw It or Lose It, into a web based application that could run across multiple platforms. The project required analyzing how the game could move from a single platform to a distributed environment that supports desktop and mobile users. The design focused on managing games, teams, and players with unique identifiers, while also planning for scalability and long term growth.

One area I feel I did well in was taking the provided scenario and translating it into practical technical recommendations. Although the project structure and template were given, I had to evaluate different operating platforms, storage approaches, and system architectures that would best support the client’s needs. I made sure that my recommendations connected clearly to the requirements rather than simply describing technical features.

Working through a structured design document before full implementation helped me better understand how system planning supports development. Breaking the project into sections made it easier to think about how each layer of the system works together. This process made the overall system design feel more intentional and organized.

If I were to revise one part of the document, I would expand the distributed systems portion, in the recommendations section, to go further into real world concerns such as failure handling and scaling under heavy traffic. While the client server structure was explained clearly, that area could include more detail about handling unexpected outages or performance spikes.

When interpreting the client’s needs, I focused on scalability, reliability, and cross platform support. The client wanted the game to move beyond Android and support multiple environments, so my design choices reflected flexibility and long term maintainability. Considering user and system needs is important because software must function well within the environment it is deployed in, not just meet basic functional requirements.

When approaching the design process, I began with the given requirements and built my analysis from there. The scenario provided the foundation, but I was responsible for evaluating platform options, storage systems, memory management techniques, and security considerations. In the future, I would continue using this structured approach by reviewing requirements first and then making architectural decisions that align with performance, stability, and user experience.
